/* tslint:disable */
/**
 * This file was automatically generated by pulumi-provider-scripts.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source Pulumi Schema file,
 * and run "pulumi-provider-scripts gen-provider-types" to regenerate this file. */
import * as pulumi from "@pulumi/pulumi";
export type ConstructComponent<T extends pulumi.ComponentResource = pulumi.ComponentResource> = (name: string, inputs: any, options: pulumi.ComponentResourceOptions) => T;
export type ResourceConstructor = {
    readonly "commandx:remote:Chmod": ConstructComponent<Chmod>;
    readonly "commandx:remote:Curl": ConstructComponent<Curl>;
    readonly "commandx:remote:Etcdctl": ConstructComponent<Etcdctl>;
    readonly "commandx:remote:Hostnamectl": ConstructComponent<Hostnamectl>;
    readonly "commandx:remote:Mkdir": ConstructComponent<Mkdir>;
    readonly "commandx:remote:Mktemp": ConstructComponent<Mktemp>;
    readonly "commandx:remote:Mv": ConstructComponent<Mv>;
    readonly "commandx:remote:Rm": ConstructComponent<Rm>;
    readonly "commandx:remote:Sed": ConstructComponent<Sed>;
    readonly "commandx:remote:Systemctl": ConstructComponent<Systemctl>;
    readonly "commandx:remote:Tar": ConstructComponent<Tar>;
    readonly "commandx:remote:Tee": ConstructComponent<Tee>;
    readonly "commandx:remote:Wget": ConstructComponent<Wget>;
};
export type Functions = {};
import * as command from "@pulumi/command";
export abstract class Chmod<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | ChmodOptsOutputs);
    public delete?: (pulumi.Output<string> | ChmodOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | ChmodOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Chmod", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface ChmodArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | ChmodOptsInputs;
    readonly delete?: pulumi.Input<string> | ChmodOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | ChmodOptsInputs;
}
export abstract class Curl<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | CurlOptsOutputs);
    public delete?: (pulumi.Output<string> | CurlOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | CurlOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Curl", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface CurlArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | CurlOptsInputs;
    readonly delete?: pulumi.Input<string> | CurlOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | CurlOptsInputs;
}
export abstract class Etcdctl<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | EtcdctlOptsOutputs);
    public delete?: (pulumi.Output<string> | EtcdctlOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | EtcdctlOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Etcdctl", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface EtcdctlArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | EtcdctlOptsInputs;
    readonly delete?: pulumi.Input<string> | EtcdctlOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | EtcdctlOptsInputs;
}
export abstract class Hostnamectl<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | HostnamectlOptsOutputs);
    public delete?: (pulumi.Output<string> | HostnamectlOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | HostnamectlOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Hostnamectl", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface HostnamectlArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | HostnamectlOptsInputs;
    readonly delete?: pulumi.Input<string> | HostnamectlOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | HostnamectlOptsInputs;
}
export abstract class Mkdir<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | MkdirOptsOutputs);
    public delete?: (pulumi.Output<string> | MkdirOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | MkdirOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Mkdir", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface MkdirArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | MkdirOptsInputs;
    readonly delete?: pulumi.Input<string> | MkdirOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | MkdirOptsInputs;
}
export abstract class Mktemp<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | MktempOptsOutputs);
    public delete?: (pulumi.Output<string> | MktempOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | MktempOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Mktemp", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface MktempArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | MktempOptsInputs;
    readonly delete?: pulumi.Input<string> | MktempOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | MktempOptsInputs;
}
export abstract class Mv<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | MvOptsOutputs);
    public delete?: (pulumi.Output<string> | MvOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | MvOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Mv", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface MvArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | MvOptsInputs;
    readonly delete?: pulumi.Input<string> | MvOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | MvOptsInputs;
}
export abstract class Rm<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | RmOptsOutputs);
    public delete?: (pulumi.Output<string> | RmOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | RmOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Rm", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface RmArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | RmOptsInputs;
    readonly delete?: pulumi.Input<string> | RmOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | RmOptsInputs;
}
export abstract class Sed<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | SedOptsOutputs);
    public delete?: (pulumi.Output<string> | SedOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | SedOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Sed", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface SedArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | SedOptsInputs;
    readonly delete?: pulumi.Input<string> | SedOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | SedOptsInputs;
}
export abstract class Systemctl<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | SystemctlOptsOutputs);
    public delete?: (pulumi.Output<string> | SystemctlOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | SystemctlOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Systemctl", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface SystemctlArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | SystemctlOptsInputs;
    readonly delete?: pulumi.Input<string> | SystemctlOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | SystemctlOptsInputs;
}
export abstract class Tar<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | TarOptsOutputs);
    public delete?: (pulumi.Output<string> | TarOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | TarOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Tar", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface TarArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | TarOptsInputs;
    readonly delete?: pulumi.Input<string> | TarOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | TarOptsInputs;
}
export abstract class Tee<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | TeeOptsOutputs);
    public delete?: (pulumi.Output<string> | TeeOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | TeeOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Tee", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface TeeArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | TeeOptsInputs;
    readonly delete?: pulumi.Input<string> | TeeOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | TeeOptsInputs;
}
export abstract class Wget<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | WgetOptsOutputs);
    public delete?: (pulumi.Output<string> | WgetOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | WgetOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("commandx:remote:Wget", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface WgetArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | WgetOptsInputs;
    readonly delete?: pulumi.Input<string> | WgetOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | WgetOptsInputs;
}
export interface ChmodOptsInputs {
    readonly changes?: pulumi.Input<boolean>;
    readonly files: pulumi.Input<pulumi.Input<string>[]>;
    readonly help?: pulumi.Input<boolean>;
    readonly mode: pulumi.Input<string>;
    readonly noPreserveRoot?: pulumi.Input<boolean>;
    readonly preserveRoot?: pulumi.Input<boolean>;
    readonly quiet?: pulumi.Input<boolean>;
    readonly recursive?: pulumi.Input<boolean>;
    readonly reference?: pulumi.Input<string>;
    readonly silent?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<boolean>;
}
export interface ChmodOptsOutputs {
    readonly changes?: pulumi.Output<boolean>;
    readonly files: pulumi.Output<string[]>;
    readonly help?: pulumi.Output<boolean>;
    readonly mode: pulumi.Output<string>;
    readonly noPreserveRoot?: pulumi.Output<boolean>;
    readonly preserveRoot?: pulumi.Output<boolean>;
    readonly quiet?: pulumi.Output<boolean>;
    readonly recursive?: pulumi.Output<boolean>;
    readonly reference?: pulumi.Output<string>;
    readonly silent?: pulumi.Output<boolean>;
    readonly version?: pulumi.Output<boolean>;
}
export type CommandLifecycleInputs = "create" | "update" | "delete";
export type CommandLifecycleOutputs = "create" | "update" | "delete";
export type CurlCertTypeInputs = "PEM" | "DER" | "ENG" | "P12";
export type CurlCertTypeOutputs = "PEM" | "DER" | "ENG" | "P12";
export type CurlDelegationLevelInputs = "none" | "policy" | "always";
export type CurlDelegationLevelOutputs = "none" | "policy" | "always";
export interface CurlOptsInputs {
    readonly abstractUnixSocket?: pulumi.Input<string>;
    readonly altSvc?: pulumi.Input<string>;
    readonly anyAuth?: pulumi.Input<boolean>;
    readonly append?: pulumi.Input<boolean>;
    readonly awsSigv4?: pulumi.Input<string>;
    readonly basic?: pulumi.Input<boolean>;
    readonly cacert?: pulumi.Input<string>;
    readonly capath?: pulumi.Input<string>;
    readonly cert?: pulumi.Input<string>;
    readonly certStatus?: pulumi.Input<boolean>;
    readonly certType?: pulumi.Input<CurlCertTypeInputs>;
    readonly ciphers?: pulumi.Input<string>;
    readonly compressed?: pulumi.Input<boolean>;
    readonly compressedSsh?: pulumi.Input<boolean>;
    readonly config?: pulumi.Input<string>;
    readonly connectTimeout?: pulumi.Input<number>;
    readonly connectTo?: pulumi.Input<string>;
    readonly continueAt?: pulumi.Input<string>;
    readonly cookie?: pulumi.Input<string>;
    readonly cookieJar?: pulumi.Input<string>;
    readonly createDirs?: pulumi.Input<boolean>;
    readonly createFileMode?: pulumi.Input<string>;
    readonly crlf?: pulumi.Input<boolean>;
    readonly crlfFile?: pulumi.Input<string>;
    readonly curves?: pulumi.Input<string>;
    readonly data?: pulumi.Input<string>;
    readonly dataAscii?: pulumi.Input<string>;
    readonly dataBinary?: pulumi.Input<string>;
    readonly dataRaw?: pulumi.Input<string>;
    readonly dataUrlEncode?: pulumi.Input<string>;
    readonly delegation?: pulumi.Input<CurlDelegationLevelInputs>;
    readonly digest?: pulumi.Input<boolean>;
    readonly disable?: pulumi.Input<boolean>;
    readonly disableEprt?: pulumi.Input<boolean>;
    readonly disableEpsv?: pulumi.Input<boolean>;
    readonly disallowUsernameInUrl?: pulumi.Input<boolean>;
    readonly dnsInterface?: pulumi.Input<string>;
    readonly dnsIpv4Addr?: pulumi.Input<string>;
    readonly dnsIpv6Addr?: pulumi.Input<string>;
    readonly dnsServers?: pulumi.Input<string>;
    readonly dohCertStatus?: pulumi.Input<boolean>;
    readonly dohInsecure?: pulumi.Input<boolean>;
    readonly dohUrl?: pulumi.Input<string>;
    readonly dumpHeader?: pulumi.Input<string>;
    readonly egdFile?: pulumi.Input<string>;
    readonly engine?: pulumi.Input<string>;
    readonly etagCompare?: pulumi.Input<string>;
    readonly etagSave?: pulumi.Input<string>;
    readonly expect100Timeout?: pulumi.Input<number>;
    readonly fail?: pulumi.Input<boolean>;
    readonly failEarly?: pulumi.Input<boolean>;
    readonly failWithBody?: pulumi.Input<boolean>;
    readonly falseStart?: pulumi.Input<boolean>;
    readonly form?: pulumi.Input<string>;
    readonly formEscape?: pulumi.Input<boolean>;
    readonly formName?: pulumi.Input<string>;
    readonly ftpAccount?: pulumi.Input<string>;
    readonly ftpAlternativeUser?: pulumi.Input<string>;
    readonly ftpCreateDirs?: pulumi.Input<boolean>;
    readonly ftpMethod?: pulumi.Input<string>;
    readonly ftpPasv?: pulumi.Input<boolean>;
    readonly ftpPort?: pulumi.Input<string>;
    readonly ftpPret?: pulumi.Input<boolean>;
    readonly ftpSkipPasvIp?: pulumi.Input<boolean>;
    readonly ftpSslCccMode?: pulumi.Input<string>;
    readonly urls: pulumi.Input<pulumi.Input<string>[]>;
}
export interface CurlOptsOutputs {
    readonly abstractUnixSocket?: pulumi.Output<string>;
    readonly altSvc?: pulumi.Output<string>;
    readonly anyAuth?: pulumi.Output<boolean>;
    readonly append?: pulumi.Output<boolean>;
    readonly awsSigv4?: pulumi.Output<string>;
    readonly basic?: pulumi.Output<boolean>;
    readonly cacert?: pulumi.Output<string>;
    readonly capath?: pulumi.Output<string>;
    readonly cert?: pulumi.Output<string>;
    readonly certStatus?: pulumi.Output<boolean>;
    readonly certType?: pulumi.Output<CurlCertTypeOutputs>;
    readonly ciphers?: pulumi.Output<string>;
    readonly compressed?: pulumi.Output<boolean>;
    readonly compressedSsh?: pulumi.Output<boolean>;
    readonly config?: pulumi.Output<string>;
    readonly connectTimeout?: pulumi.Output<number>;
    readonly connectTo?: pulumi.Output<string>;
    readonly continueAt?: pulumi.Output<string>;
    readonly cookie?: pulumi.Output<string>;
    readonly cookieJar?: pulumi.Output<string>;
    readonly createDirs?: pulumi.Output<boolean>;
    readonly createFileMode?: pulumi.Output<string>;
    readonly crlf?: pulumi.Output<boolean>;
    readonly crlfFile?: pulumi.Output<string>;
    readonly curves?: pulumi.Output<string>;
    readonly data?: pulumi.Output<string>;
    readonly dataAscii?: pulumi.Output<string>;
    readonly dataBinary?: pulumi.Output<string>;
    readonly dataRaw?: pulumi.Output<string>;
    readonly dataUrlEncode?: pulumi.Output<string>;
    readonly delegation?: pulumi.Output<CurlDelegationLevelOutputs>;
    readonly digest?: pulumi.Output<boolean>;
    readonly disable?: pulumi.Output<boolean>;
    readonly disableEprt?: pulumi.Output<boolean>;
    readonly disableEpsv?: pulumi.Output<boolean>;
    readonly disallowUsernameInUrl?: pulumi.Output<boolean>;
    readonly dnsInterface?: pulumi.Output<string>;
    readonly dnsIpv4Addr?: pulumi.Output<string>;
    readonly dnsIpv6Addr?: pulumi.Output<string>;
    readonly dnsServers?: pulumi.Output<string>;
    readonly dohCertStatus?: pulumi.Output<boolean>;
    readonly dohInsecure?: pulumi.Output<boolean>;
    readonly dohUrl?: pulumi.Output<string>;
    readonly dumpHeader?: pulumi.Output<string>;
    readonly egdFile?: pulumi.Output<string>;
    readonly engine?: pulumi.Output<string>;
    readonly etagCompare?: pulumi.Output<string>;
    readonly etagSave?: pulumi.Output<string>;
    readonly expect100Timeout?: pulumi.Output<number>;
    readonly fail?: pulumi.Output<boolean>;
    readonly failEarly?: pulumi.Output<boolean>;
    readonly failWithBody?: pulumi.Output<boolean>;
    readonly falseStart?: pulumi.Output<boolean>;
    readonly form?: pulumi.Output<string>;
    readonly formEscape?: pulumi.Output<boolean>;
    readonly formName?: pulumi.Output<string>;
    readonly ftpAccount?: pulumi.Output<string>;
    readonly ftpAlternativeUser?: pulumi.Output<string>;
    readonly ftpCreateDirs?: pulumi.Output<boolean>;
    readonly ftpMethod?: pulumi.Output<string>;
    readonly ftpPasv?: pulumi.Output<boolean>;
    readonly ftpPort?: pulumi.Output<string>;
    readonly ftpPret?: pulumi.Output<boolean>;
    readonly ftpSkipPasvIp?: pulumi.Output<boolean>;
    readonly ftpSslCccMode?: pulumi.Output<string>;
    readonly urls: pulumi.Output<string[]>;
}
export type EtcdctlCommandInputs = "member" | "list" | "version";
export type EtcdctlCommandOutputs = "member" | "list" | "version";
export interface EtcdctlOptsInputs {
    readonly caCert?: pulumi.Input<string>;
    readonly cert?: pulumi.Input<string>;
    readonly commands: pulumi.Input<EtcdctlCommandInputs>;
    readonly endpoints?: pulumi.Input<string>;
    readonly key?: pulumi.Input<string>;
}
export interface EtcdctlOptsOutputs {
    readonly caCert?: pulumi.Output<string>;
    readonly cert?: pulumi.Output<string>;
    readonly commands: pulumi.Output<EtcdctlCommandOutputs>;
    readonly endpoints?: pulumi.Output<string>;
    readonly key?: pulumi.Output<string>;
}
export type HostnamectlCommandInputs = "status" | "hostname" | "icon-name" | "chassis" | "deployment" | "location";
export type HostnamectlCommandOutputs = "status" | "hostname" | "icon-name" | "chassis" | "deployment" | "location";
export type HostnamectlJsonModeInputs = "short" | "pretty" | "off";
export type HostnamectlJsonModeOutputs = "short" | "pretty" | "off";
export interface HostnamectlOptsInputs {
    readonly arg?: pulumi.Input<string>;
    readonly command: pulumi.Input<HostnamectlCommandInputs>;
    readonly help?: pulumi.Input<boolean>;
    readonly host?: pulumi.Input<string>;
    readonly json?: pulumi.Input<HostnamectlJsonModeInputs>;
    readonly machine?: pulumi.Input<string>;
    readonly noAskPassword?: pulumi.Input<boolean>;
    readonly pretty?: pulumi.Input<boolean>;
    readonly static?: pulumi.Input<boolean>;
    readonly transient?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<boolean>;
}
export interface HostnamectlOptsOutputs {
    readonly arg?: pulumi.Output<string>;
    readonly command: pulumi.Output<HostnamectlCommandOutputs>;
    readonly help?: pulumi.Output<boolean>;
    readonly host?: pulumi.Output<string>;
    readonly json?: pulumi.Output<HostnamectlJsonModeOutputs>;
    readonly machine?: pulumi.Output<string>;
    readonly noAskPassword?: pulumi.Output<boolean>;
    readonly pretty?: pulumi.Output<boolean>;
    readonly static?: pulumi.Output<boolean>;
    readonly transient?: pulumi.Output<boolean>;
    readonly version?: pulumi.Output<boolean>;
}
export interface MkdirOptsInputs {
    readonly directory: pulumi.Input<string>;
    readonly parents?: pulumi.Input<boolean>;
    readonly removeOnDelete?: pulumi.Input<boolean>;
}
export interface MkdirOptsOutputs {
    readonly directory: pulumi.Output<string>;
    readonly parents?: pulumi.Output<boolean>;
    readonly removeOnDelete?: pulumi.Output<boolean>;
}
export interface MktempOptsInputs {
    readonly directory?: pulumi.Input<boolean>;
    readonly dryRun?: pulumi.Input<boolean>;
    readonly quiet?: pulumi.Input<boolean>;
    readonly suffix?: pulumi.Input<string>;
    readonly template?: pulumi.Input<string>;
    readonly tmpdir?: pulumi.Input<string>;
}
export interface MktempOptsOutputs {
    readonly directory?: pulumi.Output<boolean>;
    readonly dryRun?: pulumi.Output<boolean>;
    readonly quiet?: pulumi.Output<boolean>;
    readonly suffix?: pulumi.Output<string>;
    readonly template?: pulumi.Output<string>;
    readonly tmpdir?: pulumi.Output<string>;
}
export interface MvOptsInputs {
    readonly backup?: boolean;
    readonly context?: pulumi.Input<boolean>;
    readonly control?: pulumi.Input<boolean>;
    readonly dest?: pulumi.Input<string>;
    readonly directory?: pulumi.Input<string>;
    readonly force?: pulumi.Input<boolean>;
    readonly noClobber?: pulumi.Input<boolean>;
    readonly noTargetDirectory?: pulumi.Input<boolean>;
    readonly source: pulumi.Input<pulumi.Input<string>[]>;
    readonly stripTrailingSlashes?: pulumi.Input<boolean>;
    readonly suffix?: pulumi.Input<string>;
    readonly targetDirectory?: pulumi.Input<boolean>;
    readonly update?: pulumi.Input<boolean>;
    readonly verbose?: pulumi.Input<boolean>;
}
export interface MvOptsOutputs {
    readonly backup?: boolean;
    readonly context?: pulumi.Output<boolean>;
    readonly control?: pulumi.Output<boolean>;
    readonly dest?: pulumi.Output<string>;
    readonly directory?: pulumi.Output<string>;
    readonly force?: pulumi.Output<boolean>;
    readonly noClobber?: pulumi.Output<boolean>;
    readonly noTargetDirectory?: pulumi.Output<boolean>;
    readonly source: pulumi.Output<string[]>;
    readonly stripTrailingSlashes?: pulumi.Output<boolean>;
    readonly suffix?: pulumi.Output<string>;
    readonly targetDirectory?: pulumi.Output<boolean>;
    readonly update?: pulumi.Output<boolean>;
    readonly verbose?: pulumi.Output<boolean>;
}
export interface RmOptsInputs {
    readonly dir?: pulumi.Input<boolean>;
    readonly files: pulumi.Input<pulumi.Input<string>[]>;
    readonly force?: pulumi.Input<boolean>;
    readonly onDelete?: pulumi.Input<boolean>;
    readonly recursive?: pulumi.Input<boolean>;
    readonly verbose?: pulumi.Input<boolean>;
}
export interface RmOptsOutputs {
    readonly dir?: pulumi.Output<boolean>;
    readonly files: pulumi.Output<string[]>;
    readonly force?: pulumi.Output<boolean>;
    readonly onDelete?: pulumi.Output<boolean>;
    readonly recursive?: pulumi.Output<boolean>;
    readonly verbose?: pulumi.Output<boolean>;
}
export interface SedOptsInputs {
    readonly debug?: pulumi.Input<boolean>;
    readonly expressions?: pulumi.Input<pulumi.Input<string>[]>;
    readonly files?: pulumi.Input<pulumi.Input<string>[]>;
    readonly followSymlinks?: pulumi.Input<boolean>;
    readonly help?: pulumi.Input<boolean>;
    readonly inPlace?: pulumi.Input<string>;
    readonly inputFiles?: pulumi.Input<pulumi.Input<string>[]>;
    readonly lineLength?: pulumi.Input<number>;
    readonly nullData?: pulumi.Input<boolean>;
    readonly posix?: pulumi.Input<boolean>;
    readonly quiet?: pulumi.Input<boolean>;
    readonly regexpExtended?: pulumi.Input<boolean>;
    readonly sandbox?: pulumi.Input<boolean>;
    readonly script?: pulumi.Input<string>;
    readonly separate?: pulumi.Input<boolean>;
    readonly silent?: pulumi.Input<boolean>;
    readonly unbuffered?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<boolean>;
}
export interface SedOptsOutputs {
    readonly debug?: pulumi.Output<boolean>;
    readonly expressions?: pulumi.Output<string[]>;
    readonly files?: pulumi.Output<string[]>;
    readonly followSymlinks?: pulumi.Output<boolean>;
    readonly help?: pulumi.Output<boolean>;
    readonly inPlace?: pulumi.Output<string>;
    readonly inputFiles?: pulumi.Output<string[]>;
    readonly lineLength?: pulumi.Output<number>;
    readonly nullData?: pulumi.Output<boolean>;
    readonly posix?: pulumi.Output<boolean>;
    readonly quiet?: pulumi.Output<boolean>;
    readonly regexpExtended?: pulumi.Output<boolean>;
    readonly sandbox?: pulumi.Output<boolean>;
    readonly script?: pulumi.Output<string>;
    readonly separate?: pulumi.Output<boolean>;
    readonly silent?: pulumi.Output<boolean>;
    readonly unbuffered?: pulumi.Output<boolean>;
    readonly version?: pulumi.Output<boolean>;
}
export type SystemctlCommandInputs = "bind" | "cat" | "clean" | "daemon-reload" | "disable" | "enable" | "freeze" | "is-active" | "is-enabled" | "is-failed" | "isolate" | "kill" | "list-automounts" | "list-dependencies" | "list-paths" | "list-sockets" | "list-timers" | "list-units" | "mask" | "mount-image" | "reenable" | "reload" | "reload-or-restart" | "restart" | "set-property" | "show" | "start" | "status" | "stop" | "thaw" | "try-reload-or-restart" | "try-restart" | "unmask";
export type SystemctlCommandOutputs = "bind" | "cat" | "clean" | "daemon-reload" | "disable" | "enable" | "freeze" | "is-active" | "is-enabled" | "is-failed" | "isolate" | "kill" | "list-automounts" | "list-dependencies" | "list-paths" | "list-sockets" | "list-timers" | "list-units" | "mask" | "mount-image" | "reenable" | "reload" | "reload-or-restart" | "restart" | "set-property" | "show" | "start" | "status" | "stop" | "thaw" | "try-reload-or-restart" | "try-restart" | "unmask";
export interface SystemctlOptsInputs {
    readonly command: SystemctlCommandInputs;
    readonly now?: pulumi.Input<boolean>;
    readonly pattern?: pulumi.Input<string>;
    readonly unit: pulumi.Input<string>;
}
export interface SystemctlOptsOutputs {
    readonly command: SystemctlCommandOutputs;
    readonly now?: pulumi.Output<boolean>;
    readonly pattern?: pulumi.Output<string>;
    readonly unit: pulumi.Output<string>;
}
export interface TarOptsInputs {
    readonly archive: pulumi.Input<string>;
    readonly directory?: pulumi.Input<string>;
    readonly extract?: pulumi.Input<boolean>;
    readonly files?: pulumi.Input<pulumi.Input<string>[]>;
    readonly gzip?: pulumi.Input<boolean>;
    readonly onDelete?: pulumi.Input<boolean>;
    readonly recursive?: pulumi.Input<boolean>;
    readonly stripComponents?: pulumi.Input<number>;
}
export interface TarOptsOutputs {
    readonly archive: pulumi.Output<string>;
    readonly directory?: pulumi.Output<string>;
    readonly extract?: pulumi.Output<boolean>;
    readonly files?: pulumi.Output<string[]>;
    readonly gzip?: pulumi.Output<boolean>;
    readonly onDelete?: pulumi.Output<boolean>;
    readonly recursive?: pulumi.Output<boolean>;
    readonly stripComponents?: pulumi.Output<number>;
}
export type TeeModeInputs = "warn" | "warn-nopipe" | "exit" | "exit-nopipe";
export type TeeModeOutputs = "warn" | "warn-nopipe" | "exit" | "exit-nopipe";
export interface TeeOptsInputs {
    readonly append?: pulumi.Input<boolean>;
    readonly files: pulumi.Input<pulumi.Input<string>[]>;
    readonly ignoreInterrupts?: pulumi.Input<boolean>;
    readonly outputError?: pulumi.Input<TeeModeInputs>;
    readonly pipe?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<boolean>;
}
export interface TeeOptsOutputs {
    readonly append?: pulumi.Output<boolean>;
    readonly files: pulumi.Output<string[]>;
    readonly ignoreInterrupts?: pulumi.Output<boolean>;
    readonly outputError?: pulumi.Output<TeeModeOutputs>;
    readonly pipe?: pulumi.Output<boolean>;
    readonly version?: pulumi.Output<boolean>;
}
export interface WgetOptsInputs {
    readonly directoryPrefix?: pulumi.Input<string>;
    readonly httpsOnly?: pulumi.Input<boolean>;
    readonly noVerbose?: pulumi.Input<boolean>;
    readonly outputDocument?: pulumi.Input<string>;
    readonly quiet?: pulumi.Input<boolean>;
    readonly timestamping?: pulumi.Input<boolean>;
    readonly url: pulumi.Input<pulumi.Input<string>[]>;
}
export interface WgetOptsOutputs {
    readonly directoryPrefix?: pulumi.Output<string>;
    readonly httpsOnly?: pulumi.Output<boolean>;
    readonly noVerbose?: pulumi.Output<boolean>;
    readonly outputDocument?: pulumi.Output<string>;
    readonly quiet?: pulumi.Output<boolean>;
    readonly timestamping?: pulumi.Output<boolean>;
    readonly url: pulumi.Output<string[]>;
}
