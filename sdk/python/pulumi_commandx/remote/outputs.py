# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'ChmodOpts',
    'CurlOpts',
    'EtcdctlOpts',
    'HostnamectlOpts',
    'MkdirOpts',
    'MktempOpts',
    'MvOpts',
    'RmOpts',
    'SedOpts',
    'SystemctlOpts',
    'TarOpts',
    'TeeOpts',
    'WgetOpts',
]

@pulumi.output_type
class ChmodOpts(dict):
    """
    Abstraction over the `chmod` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noPreserveRoot":
            suggest = "no_preserve_root"
        elif key == "preserveRoot":
            suggest = "preserve_root"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChmodOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChmodOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChmodOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 files: Sequence[str],
                 mode: str,
                 changes: Optional[bool] = None,
                 help: Optional[bool] = None,
                 no_preserve_root: Optional[bool] = None,
                 preserve_root: Optional[bool] = None,
                 quiet: Optional[bool] = None,
                 recursive: Optional[bool] = None,
                 reference: Optional[str] = None,
                 silent: Optional[bool] = None,
                 version: Optional[bool] = None):
        """
        Abstraction over the `chmod` utility on a remote system.
        :param Sequence[str] files: Corresponds to the [FILE] argument.
        :param str mode: Modes may be absolute or symbolic. An absolute mode is an octal number...
        :param bool changes: Like verbose but report only when a change is made.
        :param bool help: Display help and exit.
        :param bool no_preserve_root: Do not treat '/' specially (the default).
        :param bool preserve_root: Fail to operate recursively on '/'.
        :param bool quiet: Suppress most error messages. Same as `silent`.
        :param bool recursive: Change files and directories recursively.
        :param str reference: Use RFILE's mode instead of specifying MODE values. RFILE is always dereferenced if a symbolic link.
        :param bool silent: Suppress most error messages. Same as `quiet`.
        :param bool version: Output version information and exit.
        """
        pulumi.set(__self__, "files", files)
        pulumi.set(__self__, "mode", mode)
        if changes is not None:
            pulumi.set(__self__, "changes", changes)
        if help is not None:
            pulumi.set(__self__, "help", help)
        if no_preserve_root is not None:
            pulumi.set(__self__, "no_preserve_root", no_preserve_root)
        if preserve_root is not None:
            pulumi.set(__self__, "preserve_root", preserve_root)
        if quiet is not None:
            pulumi.set(__self__, "quiet", quiet)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if silent is not None:
            pulumi.set(__self__, "silent", silent)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def files(self) -> Sequence[str]:
        """
        Corresponds to the [FILE] argument.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Modes may be absolute or symbolic. An absolute mode is an octal number...
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def changes(self) -> Optional[bool]:
        """
        Like verbose but report only when a change is made.
        """
        return pulumi.get(self, "changes")

    @property
    @pulumi.getter
    def help(self) -> Optional[bool]:
        """
        Display help and exit.
        """
        return pulumi.get(self, "help")

    @property
    @pulumi.getter(name="noPreserveRoot")
    def no_preserve_root(self) -> Optional[bool]:
        """
        Do not treat '/' specially (the default).
        """
        return pulumi.get(self, "no_preserve_root")

    @property
    @pulumi.getter(name="preserveRoot")
    def preserve_root(self) -> Optional[bool]:
        """
        Fail to operate recursively on '/'.
        """
        return pulumi.get(self, "preserve_root")

    @property
    @pulumi.getter
    def quiet(self) -> Optional[bool]:
        """
        Suppress most error messages. Same as `silent`.
        """
        return pulumi.get(self, "quiet")

    @property
    @pulumi.getter
    def recursive(self) -> Optional[bool]:
        """
        Change files and directories recursively.
        """
        return pulumi.get(self, "recursive")

    @property
    @pulumi.getter
    def reference(self) -> Optional[str]:
        """
        Use RFILE's mode instead of specifying MODE values. RFILE is always dereferenced if a symbolic link.
        """
        return pulumi.get(self, "reference")

    @property
    @pulumi.getter
    def silent(self) -> Optional[bool]:
        """
        Suppress most error messages. Same as `quiet`.
        """
        return pulumi.get(self, "silent")

    @property
    @pulumi.getter
    def version(self) -> Optional[bool]:
        """
        Output version information and exit.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class CurlOpts(dict):
    """
    Abstraction over the `curl` utility on a remote system. Transfer a URL.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abstractUnixSocket":
            suggest = "abstract_unix_socket"
        elif key == "altSvc":
            suggest = "alt_svc"
        elif key == "anyAuth":
            suggest = "any_auth"
        elif key == "awsSigv4":
            suggest = "aws_sigv4"
        elif key == "certStatus":
            suggest = "cert_status"
        elif key == "certType":
            suggest = "cert_type"
        elif key == "compressedSsh":
            suggest = "compressed_ssh"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "connectTo":
            suggest = "connect_to"
        elif key == "continueAt":
            suggest = "continue_at"
        elif key == "cookieJar":
            suggest = "cookie_jar"
        elif key == "createDirs":
            suggest = "create_dirs"
        elif key == "createFileMode":
            suggest = "create_file_mode"
        elif key == "crlfFile":
            suggest = "crlf_file"
        elif key == "dataAscii":
            suggest = "data_ascii"
        elif key == "dataBinary":
            suggest = "data_binary"
        elif key == "dataRaw":
            suggest = "data_raw"
        elif key == "dataUrlEncode":
            suggest = "data_url_encode"
        elif key == "disableEprt":
            suggest = "disable_eprt"
        elif key == "disableEpsv":
            suggest = "disable_epsv"
        elif key == "disallowUsernameInUrl":
            suggest = "disallow_username_in_url"
        elif key == "dnsInterface":
            suggest = "dns_interface"
        elif key == "dnsIpv4Addr":
            suggest = "dns_ipv4_addr"
        elif key == "dnsIpv6Addr":
            suggest = "dns_ipv6_addr"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "dohCertStatus":
            suggest = "doh_cert_status"
        elif key == "dohInsecure":
            suggest = "doh_insecure"
        elif key == "dohUrl":
            suggest = "doh_url"
        elif key == "dumpHeader":
            suggest = "dump_header"
        elif key == "egdFile":
            suggest = "egd_file"
        elif key == "etagCompare":
            suggest = "etag_compare"
        elif key == "etagSave":
            suggest = "etag_save"
        elif key == "expect100Timeout":
            suggest = "expect100_timeout"
        elif key == "failEarly":
            suggest = "fail_early"
        elif key == "failWithBody":
            suggest = "fail_with_body"
        elif key == "falseStart":
            suggest = "false_start"
        elif key == "formEscape":
            suggest = "form_escape"
        elif key == "formName":
            suggest = "form_name"
        elif key == "ftpAccount":
            suggest = "ftp_account"
        elif key == "ftpAlternativeUser":
            suggest = "ftp_alternative_user"
        elif key == "ftpCreateDirs":
            suggest = "ftp_create_dirs"
        elif key == "ftpMethod":
            suggest = "ftp_method"
        elif key == "ftpPasv":
            suggest = "ftp_pasv"
        elif key == "ftpPort":
            suggest = "ftp_port"
        elif key == "ftpPret":
            suggest = "ftp_pret"
        elif key == "ftpSkipPasvIp":
            suggest = "ftp_skip_pasv_ip"
        elif key == "ftpSslCccMode":
            suggest = "ftp_ssl_ccc_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CurlOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CurlOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CurlOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 urls: Sequence[str],
                 abstract_unix_socket: Optional[str] = None,
                 alt_svc: Optional[str] = None,
                 any_auth: Optional[bool] = None,
                 append: Optional[bool] = None,
                 aws_sigv4: Optional[str] = None,
                 basic: Optional[bool] = None,
                 cacert: Optional[str] = None,
                 capath: Optional[str] = None,
                 cert: Optional[str] = None,
                 cert_status: Optional[bool] = None,
                 cert_type: Optional['CurlCertType'] = None,
                 ciphers: Optional[str] = None,
                 compressed: Optional[bool] = None,
                 compressed_ssh: Optional[bool] = None,
                 config: Optional[str] = None,
                 connect_timeout: Optional[int] = None,
                 connect_to: Optional[str] = None,
                 continue_at: Optional[str] = None,
                 cookie: Optional[str] = None,
                 cookie_jar: Optional[str] = None,
                 create_dirs: Optional[bool] = None,
                 create_file_mode: Optional[str] = None,
                 crlf: Optional[bool] = None,
                 crlf_file: Optional[str] = None,
                 curves: Optional[str] = None,
                 data: Optional[str] = None,
                 data_ascii: Optional[str] = None,
                 data_binary: Optional[str] = None,
                 data_raw: Optional[str] = None,
                 data_url_encode: Optional[str] = None,
                 delegation: Optional['CurlDelegationLevel'] = None,
                 digest: Optional[bool] = None,
                 disable: Optional[bool] = None,
                 disable_eprt: Optional[bool] = None,
                 disable_epsv: Optional[bool] = None,
                 disallow_username_in_url: Optional[bool] = None,
                 dns_interface: Optional[str] = None,
                 dns_ipv4_addr: Optional[str] = None,
                 dns_ipv6_addr: Optional[str] = None,
                 dns_servers: Optional[str] = None,
                 doh_cert_status: Optional[bool] = None,
                 doh_insecure: Optional[bool] = None,
                 doh_url: Optional[str] = None,
                 dump_header: Optional[str] = None,
                 egd_file: Optional[str] = None,
                 engine: Optional[str] = None,
                 etag_compare: Optional[str] = None,
                 etag_save: Optional[str] = None,
                 expect100_timeout: Optional[int] = None,
                 fail: Optional[bool] = None,
                 fail_early: Optional[bool] = None,
                 fail_with_body: Optional[bool] = None,
                 false_start: Optional[bool] = None,
                 form: Optional[str] = None,
                 form_escape: Optional[bool] = None,
                 form_name: Optional[str] = None,
                 ftp_account: Optional[str] = None,
                 ftp_alternative_user: Optional[str] = None,
                 ftp_create_dirs: Optional[bool] = None,
                 ftp_method: Optional[str] = None,
                 ftp_pasv: Optional[bool] = None,
                 ftp_port: Optional[str] = None,
                 ftp_pret: Optional[bool] = None,
                 ftp_skip_pasv_ip: Optional[bool] = None,
                 ftp_ssl_ccc_mode: Optional[str] = None):
        """
        Abstraction over the `curl` utility on a remote system. Transfer a URL.
        :param Sequence[str] urls: Corresponds to the URLs argument.
        :param str abstract_unix_socket: (HTTP) Connect through an abstract Unix domain socket, instead of using the network.
        :param str alt_svc: (HTTPS)  This  option enables the alt-svc parser in curl.
        :param bool any_auth: (HTTP) Tells curl to figure out authentication method by itself, and use the most secure one the remote site claims to support.
        :param bool append: (FTP SFTP) When used in an upload, this makes curl append to the target file instead of overwriting it.
        :param str aws_sigv4: Use AWS V4 signature authentication in the transfer.
        :param bool basic: (HTTP) Tells curl to use HTTP Basic authentication with the remote host.
        :param str cacert: (TLS)  Tells curl to use the specified certificate file to verify the peer.
        :param str capath: (TLS) Tells curl to use the specified certificate directory to verify the peer.
        :param str cert: (TLS)  Tells  curl to use the specified client certificate file when getting a file with HTTPS, FTPS or another SSL-based protocol.
        :param bool cert_status: (TLS) Tells curl to verify the status of the server certificate by using the Certificate Status Request (aka. OCSP stapling) TLS extension.
        :param 'CurlCertType' cert_type: (TLS) Tells curl what type the provided client certificate is using.
        :param str ciphers: (TLS) Specifies which ciphers to use in the connection.
        :param bool compressed: (HTTP) Request a compressed response using one of the algorithms curl supports, and automatically decompress the content.
        :param bool compressed_ssh: (SCP SFTP) Enables built-in SSH compression.
        :param str config: Specify a text file to read curl arguments from.
        :param int connect_timeout: Maximum  time  in seconds that you allow curl's connection to take.
        :param str connect_to: For a request to the given HOST1:PORT1 pair, connect to HOST2:PORT2 instead.
        :param str continue_at: Continue/Resume a previous file transfer at the given offset.
        :param str cookie: (HTTP) Pass the data to the HTTP server in the Cookie header.
        :param str cookie_jar: (HTTP)  Specify  to which file you want curl to write all cookies after a completed operation.
        :param bool create_dirs: When used in conjunction with the -o, --output option, curl will create the necessary local directory hierarchy as needed.
        :param str create_file_mode: (SFTP SCP FILE) When curl is used to create files remotely using one of the supported protocols, this option allows the user to set which 'mode' to set on the file at creation time, instead of the default 0644.
        :param bool crlf: (FTP SMTP) Convert LF to CRLF in upload. Useful for MVS (OS/390).
        :param str crlf_file: (TLS) Provide a file using PEM format with a Certificate Revocation List that may specify peer certificates that are to be considered revoked.
        :param str curves: (TLS)  Tells curl to request specific curves to use during SSL session establishment according to RFC 8422, 5.1.
        :param str data: (HTTP  MQTT) Sends the specified data in a POST request to the HTTP server, in the same way that a browser does when a user has filled in an HTML form and presses the submit button.
        :param str data_ascii: (HTTP) This is just an alias for -d, --data.
        :param str data_binary: (HTTP) This posts data exactly as specified with no extra processing whatsoever.
        :param str data_raw: (HTTP) This posts data similarly to -d, --data but without the special interpretation of the @ character.
        :param str data_url_encode: (HTTP) This posts data, similar to the other -d, --data options with the exception that this performs URL-encoding.
        :param 'CurlDelegationLevel' delegation: (GSS/kerberos) Set LEVEL to tell the server what it is allowed to delegate when it comes to user credentials.
        :param bool digest: (HTTP) Enables HTTP Digest authentication.
        :param bool disable: If used as the first parameter on the command line, the curlrc config file will not be read and used.
        :param bool disable_eprt: (FTP) Tell curl to disable the use of the EPRT and LPRT commands when doing active FTP transfers
        :param bool disable_epsv: (FTP)  Tell  curl to disable the use of the EPSV command when doing passive FTP transfers
        :param bool disallow_username_in_url: (HTTP) This tells curl to exit if passed a url containing a username.
        :param str dns_interface: (DNS)  Tell  curl  to send outgoing DNS requests through <interface>.
        :param str dns_ipv4_addr: (DNS) Tell curl to bind to <ip-address> when making IPv4 DNS requests, so that the DNS requests originate from this address.
        :param str dns_ipv6_addr: (DNS) Tell curl to bind to <ip-address> when making IPv6 DNS requests, so that the DNS requests originate from this address.
        :param str dns_servers: Set the list of DNS servers to be used instead of the system default.
        :param bool doh_cert_status: Same as --cert-status but used for DoH (DNS-over-HTTPS).
        :param bool doh_insecure: Same as -k, --insecure but used for DoH (DNS-over-HTTPS).
        :param str doh_url: Specifies which DNS-over-HTTPS (DoH) server to use to resolve hostnames, instead of using the default name resolver mechanism.
        :param str dump_header: (HTTP FTP) Write the received protocol headers to the specified file.
        :param str egd_file: (TLS) Specify the path name to the Entropy Gathering Daemon socket.
        :param str engine: (TLS) Select the OpenSSL crypto engine to use for cipher operations.
        :param str etag_compare: (HTTP) This option makes a conditional HTTP request for the specific ETag read from the given file by sending a custom If-None-Match header using the stored ETag.
        :param str etag_save: (HTTP) This option saves an HTTP ETag to the specified file.
        :param int expect100_timeout: (HTTP)  Maximum  time in seconds that you allow curl to wait for a 100-continue response when curl emits an Expects: 100-continue header in its request.
        :param bool fail: (HTTP) Fail silently (no output at all) on server errors.
        :param bool fail_early: Fail and exit on the first detected transfer error.
        :param bool fail_with_body: (HTTP)  Return an error on server errors where the HTTP response code is 400 or greater).
        :param bool false_start: (TLS) Tells curl to use false start during the TLS handshake.
        :param str form: (HTTP SMTP IMAP) For HTTP protocol family, this lets curl emulate a filled-in form in which a user has pressed the submit button.
        :param bool form_escape: (HTTP) Tells curl to pass on names of multipart form fields and files using backslash-escaping instead of percent-encoding.
        :param str form_name: (HTTP SMTP IMAP) Similar to -F, --form except that the value string for the named parameter is used literally.
        :param str ftp_account: (FTP) When an FTP server asks for 'account data' after user name and password has been provided, this data is sent off using the ACCT command.
        :param str ftp_alternative_user: (FTP) If authenticating with the USER and PASS commands fails, send this command.
        :param bool ftp_create_dirs: (FTP  SFTP) When an FTP or SFTP URL/operation uses a path that does not currently exist on the server, the standard behavior of curl is to fail.
        :param str ftp_method: (FTP) Control what method curl should use to reach a file on an FTP(S) server.
        :param bool ftp_pasv: (FTP) Use passive mode for the data connection.
        :param str ftp_port: (FTP)  Reverses  the  default  initiator/listener  roles  when connecting with FTP.
        :param bool ftp_pret: (FTP) Tell curl to send a PRET command before PASV (and EPSV).
        :param bool ftp_skip_pasv_ip: (FTP)  Tell  curl  to  not use the IP address the server suggests in its response to curl's PASV command when curl connects the data connection.
        :param str ftp_ssl_ccc_mode: (FTP) Sets the CCC mode. The passive mode will not initiate the shutdown, but instead wait for the server to do it, and will not reply to the shutdown from the  server.
        """
        pulumi.set(__self__, "urls", urls)
        if abstract_unix_socket is not None:
            pulumi.set(__self__, "abstract_unix_socket", abstract_unix_socket)
        if alt_svc is not None:
            pulumi.set(__self__, "alt_svc", alt_svc)
        if any_auth is not None:
            pulumi.set(__self__, "any_auth", any_auth)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if aws_sigv4 is not None:
            pulumi.set(__self__, "aws_sigv4", aws_sigv4)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if capath is not None:
            pulumi.set(__self__, "capath", capath)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if cert_status is not None:
            pulumi.set(__self__, "cert_status", cert_status)
        if cert_type is not None:
            pulumi.set(__self__, "cert_type", cert_type)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if compressed is not None:
            pulumi.set(__self__, "compressed", compressed)
        if compressed_ssh is not None:
            pulumi.set(__self__, "compressed_ssh", compressed_ssh)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if connect_to is not None:
            pulumi.set(__self__, "connect_to", connect_to)
        if continue_at is not None:
            pulumi.set(__self__, "continue_at", continue_at)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if cookie_jar is not None:
            pulumi.set(__self__, "cookie_jar", cookie_jar)
        if create_dirs is not None:
            pulumi.set(__self__, "create_dirs", create_dirs)
        if create_file_mode is not None:
            pulumi.set(__self__, "create_file_mode", create_file_mode)
        if crlf is not None:
            pulumi.set(__self__, "crlf", crlf)
        if crlf_file is not None:
            pulumi.set(__self__, "crlf_file", crlf_file)
        if curves is not None:
            pulumi.set(__self__, "curves", curves)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if data_ascii is not None:
            pulumi.set(__self__, "data_ascii", data_ascii)
        if data_binary is not None:
            pulumi.set(__self__, "data_binary", data_binary)
        if data_raw is not None:
            pulumi.set(__self__, "data_raw", data_raw)
        if data_url_encode is not None:
            pulumi.set(__self__, "data_url_encode", data_url_encode)
        if delegation is not None:
            pulumi.set(__self__, "delegation", delegation)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if disable_eprt is not None:
            pulumi.set(__self__, "disable_eprt", disable_eprt)
        if disable_epsv is not None:
            pulumi.set(__self__, "disable_epsv", disable_epsv)
        if disallow_username_in_url is not None:
            pulumi.set(__self__, "disallow_username_in_url", disallow_username_in_url)
        if dns_interface is not None:
            pulumi.set(__self__, "dns_interface", dns_interface)
        if dns_ipv4_addr is not None:
            pulumi.set(__self__, "dns_ipv4_addr", dns_ipv4_addr)
        if dns_ipv6_addr is not None:
            pulumi.set(__self__, "dns_ipv6_addr", dns_ipv6_addr)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if doh_cert_status is not None:
            pulumi.set(__self__, "doh_cert_status", doh_cert_status)
        if doh_insecure is not None:
            pulumi.set(__self__, "doh_insecure", doh_insecure)
        if doh_url is not None:
            pulumi.set(__self__, "doh_url", doh_url)
        if dump_header is not None:
            pulumi.set(__self__, "dump_header", dump_header)
        if egd_file is not None:
            pulumi.set(__self__, "egd_file", egd_file)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if etag_compare is not None:
            pulumi.set(__self__, "etag_compare", etag_compare)
        if etag_save is not None:
            pulumi.set(__self__, "etag_save", etag_save)
        if expect100_timeout is not None:
            pulumi.set(__self__, "expect100_timeout", expect100_timeout)
        if fail is not None:
            pulumi.set(__self__, "fail", fail)
        if fail_early is not None:
            pulumi.set(__self__, "fail_early", fail_early)
        if fail_with_body is not None:
            pulumi.set(__self__, "fail_with_body", fail_with_body)
        if false_start is not None:
            pulumi.set(__self__, "false_start", false_start)
        if form is not None:
            pulumi.set(__self__, "form", form)
        if form_escape is not None:
            pulumi.set(__self__, "form_escape", form_escape)
        if form_name is not None:
            pulumi.set(__self__, "form_name", form_name)
        if ftp_account is not None:
            pulumi.set(__self__, "ftp_account", ftp_account)
        if ftp_alternative_user is not None:
            pulumi.set(__self__, "ftp_alternative_user", ftp_alternative_user)
        if ftp_create_dirs is not None:
            pulumi.set(__self__, "ftp_create_dirs", ftp_create_dirs)
        if ftp_method is not None:
            pulumi.set(__self__, "ftp_method", ftp_method)
        if ftp_pasv is not None:
            pulumi.set(__self__, "ftp_pasv", ftp_pasv)
        if ftp_port is not None:
            pulumi.set(__self__, "ftp_port", ftp_port)
        if ftp_pret is not None:
            pulumi.set(__self__, "ftp_pret", ftp_pret)
        if ftp_skip_pasv_ip is not None:
            pulumi.set(__self__, "ftp_skip_pasv_ip", ftp_skip_pasv_ip)
        if ftp_ssl_ccc_mode is not None:
            pulumi.set(__self__, "ftp_ssl_ccc_mode", ftp_ssl_ccc_mode)

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        """
        Corresponds to the URLs argument.
        """
        return pulumi.get(self, "urls")

    @property
    @pulumi.getter(name="abstractUnixSocket")
    def abstract_unix_socket(self) -> Optional[str]:
        """
        (HTTP) Connect through an abstract Unix domain socket, instead of using the network.
        """
        return pulumi.get(self, "abstract_unix_socket")

    @property
    @pulumi.getter(name="altSvc")
    def alt_svc(self) -> Optional[str]:
        """
        (HTTPS)  This  option enables the alt-svc parser in curl.
        """
        return pulumi.get(self, "alt_svc")

    @property
    @pulumi.getter(name="anyAuth")
    def any_auth(self) -> Optional[bool]:
        """
        (HTTP) Tells curl to figure out authentication method by itself, and use the most secure one the remote site claims to support.
        """
        return pulumi.get(self, "any_auth")

    @property
    @pulumi.getter
    def append(self) -> Optional[bool]:
        """
        (FTP SFTP) When used in an upload, this makes curl append to the target file instead of overwriting it.
        """
        return pulumi.get(self, "append")

    @property
    @pulumi.getter(name="awsSigv4")
    def aws_sigv4(self) -> Optional[str]:
        """
        Use AWS V4 signature authentication in the transfer.
        """
        return pulumi.get(self, "aws_sigv4")

    @property
    @pulumi.getter
    def basic(self) -> Optional[bool]:
        """
        (HTTP) Tells curl to use HTTP Basic authentication with the remote host.
        """
        return pulumi.get(self, "basic")

    @property
    @pulumi.getter
    def cacert(self) -> Optional[str]:
        """
        (TLS)  Tells curl to use the specified certificate file to verify the peer.
        """
        return pulumi.get(self, "cacert")

    @property
    @pulumi.getter
    def capath(self) -> Optional[str]:
        """
        (TLS) Tells curl to use the specified certificate directory to verify the peer.
        """
        return pulumi.get(self, "capath")

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        """
        (TLS)  Tells  curl to use the specified client certificate file when getting a file with HTTPS, FTPS or another SSL-based protocol.
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter(name="certStatus")
    def cert_status(self) -> Optional[bool]:
        """
        (TLS) Tells curl to verify the status of the server certificate by using the Certificate Status Request (aka. OCSP stapling) TLS extension.
        """
        return pulumi.get(self, "cert_status")

    @property
    @pulumi.getter(name="certType")
    def cert_type(self) -> Optional['CurlCertType']:
        """
        (TLS) Tells curl what type the provided client certificate is using.
        """
        return pulumi.get(self, "cert_type")

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[str]:
        """
        (TLS) Specifies which ciphers to use in the connection.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter
    def compressed(self) -> Optional[bool]:
        """
        (HTTP) Request a compressed response using one of the algorithms curl supports, and automatically decompress the content.
        """
        return pulumi.get(self, "compressed")

    @property
    @pulumi.getter(name="compressedSsh")
    def compressed_ssh(self) -> Optional[bool]:
        """
        (SCP SFTP) Enables built-in SSH compression.
        """
        return pulumi.get(self, "compressed_ssh")

    @property
    @pulumi.getter
    def config(self) -> Optional[str]:
        """
        Specify a text file to read curl arguments from.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[int]:
        """
        Maximum  time  in seconds that you allow curl's connection to take.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="connectTo")
    def connect_to(self) -> Optional[str]:
        """
        For a request to the given HOST1:PORT1 pair, connect to HOST2:PORT2 instead.
        """
        return pulumi.get(self, "connect_to")

    @property
    @pulumi.getter(name="continueAt")
    def continue_at(self) -> Optional[str]:
        """
        Continue/Resume a previous file transfer at the given offset.
        """
        return pulumi.get(self, "continue_at")

    @property
    @pulumi.getter
    def cookie(self) -> Optional[str]:
        """
        (HTTP) Pass the data to the HTTP server in the Cookie header.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="cookieJar")
    def cookie_jar(self) -> Optional[str]:
        """
        (HTTP)  Specify  to which file you want curl to write all cookies after a completed operation.
        """
        return pulumi.get(self, "cookie_jar")

    @property
    @pulumi.getter(name="createDirs")
    def create_dirs(self) -> Optional[bool]:
        """
        When used in conjunction with the -o, --output option, curl will create the necessary local directory hierarchy as needed.
        """
        return pulumi.get(self, "create_dirs")

    @property
    @pulumi.getter(name="createFileMode")
    def create_file_mode(self) -> Optional[str]:
        """
        (SFTP SCP FILE) When curl is used to create files remotely using one of the supported protocols, this option allows the user to set which 'mode' to set on the file at creation time, instead of the default 0644.
        """
        return pulumi.get(self, "create_file_mode")

    @property
    @pulumi.getter
    def crlf(self) -> Optional[bool]:
        """
        (FTP SMTP) Convert LF to CRLF in upload. Useful for MVS (OS/390).
        """
        return pulumi.get(self, "crlf")

    @property
    @pulumi.getter(name="crlfFile")
    def crlf_file(self) -> Optional[str]:
        """
        (TLS) Provide a file using PEM format with a Certificate Revocation List that may specify peer certificates that are to be considered revoked.
        """
        return pulumi.get(self, "crlf_file")

    @property
    @pulumi.getter
    def curves(self) -> Optional[str]:
        """
        (TLS)  Tells curl to request specific curves to use during SSL session establishment according to RFC 8422, 5.1.
        """
        return pulumi.get(self, "curves")

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        (HTTP  MQTT) Sends the specified data in a POST request to the HTTP server, in the same way that a browser does when a user has filled in an HTML form and presses the submit button.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter(name="dataAscii")
    def data_ascii(self) -> Optional[str]:
        """
        (HTTP) This is just an alias for -d, --data.
        """
        return pulumi.get(self, "data_ascii")

    @property
    @pulumi.getter(name="dataBinary")
    def data_binary(self) -> Optional[str]:
        """
        (HTTP) This posts data exactly as specified with no extra processing whatsoever.
        """
        return pulumi.get(self, "data_binary")

    @property
    @pulumi.getter(name="dataRaw")
    def data_raw(self) -> Optional[str]:
        """
        (HTTP) This posts data similarly to -d, --data but without the special interpretation of the @ character.
        """
        return pulumi.get(self, "data_raw")

    @property
    @pulumi.getter(name="dataUrlEncode")
    def data_url_encode(self) -> Optional[str]:
        """
        (HTTP) This posts data, similar to the other -d, --data options with the exception that this performs URL-encoding.
        """
        return pulumi.get(self, "data_url_encode")

    @property
    @pulumi.getter
    def delegation(self) -> Optional['CurlDelegationLevel']:
        """
        (GSS/kerberos) Set LEVEL to tell the server what it is allowed to delegate when it comes to user credentials.
        """
        return pulumi.get(self, "delegation")

    @property
    @pulumi.getter
    def digest(self) -> Optional[bool]:
        """
        (HTTP) Enables HTTP Digest authentication.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def disable(self) -> Optional[bool]:
        """
        If used as the first parameter on the command line, the curlrc config file will not be read and used.
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter(name="disableEprt")
    def disable_eprt(self) -> Optional[bool]:
        """
        (FTP) Tell curl to disable the use of the EPRT and LPRT commands when doing active FTP transfers
        """
        return pulumi.get(self, "disable_eprt")

    @property
    @pulumi.getter(name="disableEpsv")
    def disable_epsv(self) -> Optional[bool]:
        """
        (FTP)  Tell  curl to disable the use of the EPSV command when doing passive FTP transfers
        """
        return pulumi.get(self, "disable_epsv")

    @property
    @pulumi.getter(name="disallowUsernameInUrl")
    def disallow_username_in_url(self) -> Optional[bool]:
        """
        (HTTP) This tells curl to exit if passed a url containing a username.
        """
        return pulumi.get(self, "disallow_username_in_url")

    @property
    @pulumi.getter(name="dnsInterface")
    def dns_interface(self) -> Optional[str]:
        """
        (DNS)  Tell  curl  to send outgoing DNS requests through <interface>.
        """
        return pulumi.get(self, "dns_interface")

    @property
    @pulumi.getter(name="dnsIpv4Addr")
    def dns_ipv4_addr(self) -> Optional[str]:
        """
        (DNS) Tell curl to bind to <ip-address> when making IPv4 DNS requests, so that the DNS requests originate from this address.
        """
        return pulumi.get(self, "dns_ipv4_addr")

    @property
    @pulumi.getter(name="dnsIpv6Addr")
    def dns_ipv6_addr(self) -> Optional[str]:
        """
        (DNS) Tell curl to bind to <ip-address> when making IPv6 DNS requests, so that the DNS requests originate from this address.
        """
        return pulumi.get(self, "dns_ipv6_addr")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[str]:
        """
        Set the list of DNS servers to be used instead of the system default.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="dohCertStatus")
    def doh_cert_status(self) -> Optional[bool]:
        """
        Same as --cert-status but used for DoH (DNS-over-HTTPS).
        """
        return pulumi.get(self, "doh_cert_status")

    @property
    @pulumi.getter(name="dohInsecure")
    def doh_insecure(self) -> Optional[bool]:
        """
        Same as -k, --insecure but used for DoH (DNS-over-HTTPS).
        """
        return pulumi.get(self, "doh_insecure")

    @property
    @pulumi.getter(name="dohUrl")
    def doh_url(self) -> Optional[str]:
        """
        Specifies which DNS-over-HTTPS (DoH) server to use to resolve hostnames, instead of using the default name resolver mechanism.
        """
        return pulumi.get(self, "doh_url")

    @property
    @pulumi.getter(name="dumpHeader")
    def dump_header(self) -> Optional[str]:
        """
        (HTTP FTP) Write the received protocol headers to the specified file.
        """
        return pulumi.get(self, "dump_header")

    @property
    @pulumi.getter(name="egdFile")
    def egd_file(self) -> Optional[str]:
        """
        (TLS) Specify the path name to the Entropy Gathering Daemon socket.
        """
        return pulumi.get(self, "egd_file")

    @property
    @pulumi.getter
    def engine(self) -> Optional[str]:
        """
        (TLS) Select the OpenSSL crypto engine to use for cipher operations.
        """
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter(name="etagCompare")
    def etag_compare(self) -> Optional[str]:
        """
        (HTTP) This option makes a conditional HTTP request for the specific ETag read from the given file by sending a custom If-None-Match header using the stored ETag.
        """
        return pulumi.get(self, "etag_compare")

    @property
    @pulumi.getter(name="etagSave")
    def etag_save(self) -> Optional[str]:
        """
        (HTTP) This option saves an HTTP ETag to the specified file.
        """
        return pulumi.get(self, "etag_save")

    @property
    @pulumi.getter(name="expect100Timeout")
    def expect100_timeout(self) -> Optional[int]:
        """
        (HTTP)  Maximum  time in seconds that you allow curl to wait for a 100-continue response when curl emits an Expects: 100-continue header in its request.
        """
        return pulumi.get(self, "expect100_timeout")

    @property
    @pulumi.getter
    def fail(self) -> Optional[bool]:
        """
        (HTTP) Fail silently (no output at all) on server errors.
        """
        return pulumi.get(self, "fail")

    @property
    @pulumi.getter(name="failEarly")
    def fail_early(self) -> Optional[bool]:
        """
        Fail and exit on the first detected transfer error.
        """
        return pulumi.get(self, "fail_early")

    @property
    @pulumi.getter(name="failWithBody")
    def fail_with_body(self) -> Optional[bool]:
        """
        (HTTP)  Return an error on server errors where the HTTP response code is 400 or greater).
        """
        return pulumi.get(self, "fail_with_body")

    @property
    @pulumi.getter(name="falseStart")
    def false_start(self) -> Optional[bool]:
        """
        (TLS) Tells curl to use false start during the TLS handshake.
        """
        return pulumi.get(self, "false_start")

    @property
    @pulumi.getter
    def form(self) -> Optional[str]:
        """
        (HTTP SMTP IMAP) For HTTP protocol family, this lets curl emulate a filled-in form in which a user has pressed the submit button.
        """
        return pulumi.get(self, "form")

    @property
    @pulumi.getter(name="formEscape")
    def form_escape(self) -> Optional[bool]:
        """
        (HTTP) Tells curl to pass on names of multipart form fields and files using backslash-escaping instead of percent-encoding.
        """
        return pulumi.get(self, "form_escape")

    @property
    @pulumi.getter(name="formName")
    def form_name(self) -> Optional[str]:
        """
        (HTTP SMTP IMAP) Similar to -F, --form except that the value string for the named parameter is used literally.
        """
        return pulumi.get(self, "form_name")

    @property
    @pulumi.getter(name="ftpAccount")
    def ftp_account(self) -> Optional[str]:
        """
        (FTP) When an FTP server asks for 'account data' after user name and password has been provided, this data is sent off using the ACCT command.
        """
        return pulumi.get(self, "ftp_account")

    @property
    @pulumi.getter(name="ftpAlternativeUser")
    def ftp_alternative_user(self) -> Optional[str]:
        """
        (FTP) If authenticating with the USER and PASS commands fails, send this command.
        """
        return pulumi.get(self, "ftp_alternative_user")

    @property
    @pulumi.getter(name="ftpCreateDirs")
    def ftp_create_dirs(self) -> Optional[bool]:
        """
        (FTP  SFTP) When an FTP or SFTP URL/operation uses a path that does not currently exist on the server, the standard behavior of curl is to fail.
        """
        return pulumi.get(self, "ftp_create_dirs")

    @property
    @pulumi.getter(name="ftpMethod")
    def ftp_method(self) -> Optional[str]:
        """
        (FTP) Control what method curl should use to reach a file on an FTP(S) server.
        """
        return pulumi.get(self, "ftp_method")

    @property
    @pulumi.getter(name="ftpPasv")
    def ftp_pasv(self) -> Optional[bool]:
        """
        (FTP) Use passive mode for the data connection.
        """
        return pulumi.get(self, "ftp_pasv")

    @property
    @pulumi.getter(name="ftpPort")
    def ftp_port(self) -> Optional[str]:
        """
        (FTP)  Reverses  the  default  initiator/listener  roles  when connecting with FTP.
        """
        return pulumi.get(self, "ftp_port")

    @property
    @pulumi.getter(name="ftpPret")
    def ftp_pret(self) -> Optional[bool]:
        """
        (FTP) Tell curl to send a PRET command before PASV (and EPSV).
        """
        return pulumi.get(self, "ftp_pret")

    @property
    @pulumi.getter(name="ftpSkipPasvIp")
    def ftp_skip_pasv_ip(self) -> Optional[bool]:
        """
        (FTP)  Tell  curl  to  not use the IP address the server suggests in its response to curl's PASV command when curl connects the data connection.
        """
        return pulumi.get(self, "ftp_skip_pasv_ip")

    @property
    @pulumi.getter(name="ftpSslCccMode")
    def ftp_ssl_ccc_mode(self) -> Optional[str]:
        """
        (FTP) Sets the CCC mode. The passive mode will not initiate the shutdown, but instead wait for the server to do it, and will not reply to the shutdown from the  server.
        """
        return pulumi.get(self, "ftp_ssl_ccc_mode")


@pulumi.output_type
class EtcdctlOpts(dict):
    """
    Abstraction over the `etcdctl` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCert":
            suggest = "ca_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EtcdctlOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EtcdctlOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EtcdctlOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: 'EtcdctlCommand',
                 ca_cert: Optional[str] = None,
                 cert: Optional[str] = None,
                 endpoints: Optional[str] = None,
                 key: Optional[str] = None):
        """
        Abstraction over the `etcdctl` utility on a remote system.
        :param 'EtcdctlCommand' commands: TODO
        :param str ca_cert: TODO
        :param str cert: TODO
        :param str endpoints: TODO
        :param str key: TODO
        """
        pulumi.set(__self__, "commands", commands)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def commands(self) -> 'EtcdctlCommand':
        """
        TODO
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        """
        TODO
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        """
        TODO
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[str]:
        """
        TODO
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        TODO
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class HostnamectlOpts(dict):
    """
    Abstraction over the `hostnamectl` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noAskPassword":
            suggest = "no_ask_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostnamectlOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostnamectlOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostnamectlOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: 'HostnamectlCommand',
                 arg: Optional[str] = None,
                 help: Optional[bool] = None,
                 host: Optional[str] = None,
                 json: Optional['HostnamectlJsonMode'] = None,
                 machine: Optional[str] = None,
                 no_ask_password: Optional[bool] = None,
                 pretty: Optional[bool] = None,
                 static: Optional[bool] = None,
                 transient: Optional[bool] = None,
                 version: Optional[bool] = None):
        """
        Abstraction over the `hostnamectl` utility on a remote system.
        :param 'HostnamectlCommand' command: Corresponds to the {COMMAND} argument.
        :param str arg: The argument for the specified `command`.
        :param bool help: Print a short help text and exit.
        :param str host: Execute the operation remotely. Specify a hostname, or a username and hostname separated by '@', to connect to.
        :param 'HostnamectlJsonMode' json: Shows output formatted as JSON.
        :param str machine: Execute operation on a local container. Specify a container name to connect to, optionally prefixed by a user name to connect as and a separating '@' character.
        :param bool no_ask_password: Do not query the user for authentication for privileged operations.
        :param bool pretty: If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `transient`.
        :param bool static: If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `transient` and `pretty`.
        :param bool transient: If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `pretty`.
        :param bool version: Print a short version string and exit.
        """
        pulumi.set(__self__, "command", command)
        if arg is not None:
            pulumi.set(__self__, "arg", arg)
        if help is not None:
            pulumi.set(__self__, "help", help)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if machine is not None:
            pulumi.set(__self__, "machine", machine)
        if no_ask_password is not None:
            pulumi.set(__self__, "no_ask_password", no_ask_password)
        if pretty is not None:
            pulumi.set(__self__, "pretty", pretty)
        if static is not None:
            pulumi.set(__self__, "static", static)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def command(self) -> 'HostnamectlCommand':
        """
        Corresponds to the {COMMAND} argument.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def arg(self) -> Optional[str]:
        """
        The argument for the specified `command`.
        """
        return pulumi.get(self, "arg")

    @property
    @pulumi.getter
    def help(self) -> Optional[bool]:
        """
        Print a short help text and exit.
        """
        return pulumi.get(self, "help")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Execute the operation remotely. Specify a hostname, or a username and hostname separated by '@', to connect to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def json(self) -> Optional['HostnamectlJsonMode']:
        """
        Shows output formatted as JSON.
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter
    def machine(self) -> Optional[str]:
        """
        Execute operation on a local container. Specify a container name to connect to, optionally prefixed by a user name to connect as and a separating '@' character.
        """
        return pulumi.get(self, "machine")

    @property
    @pulumi.getter(name="noAskPassword")
    def no_ask_password(self) -> Optional[bool]:
        """
        Do not query the user for authentication for privileged operations.
        """
        return pulumi.get(self, "no_ask_password")

    @property
    @pulumi.getter
    def pretty(self) -> Optional[bool]:
        """
        If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `transient`.
        """
        return pulumi.get(self, "pretty")

    @property
    @pulumi.getter
    def static(self) -> Optional[bool]:
        """
        If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `transient` and `pretty`.
        """
        return pulumi.get(self, "static")

    @property
    @pulumi.getter
    def transient(self) -> Optional[bool]:
        """
        If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `pretty`.
        """
        return pulumi.get(self, "transient")

    @property
    @pulumi.getter
    def version(self) -> Optional[bool]:
        """
        Print a short version string and exit.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MkdirOpts(dict):
    """
    Abstraction over the `mkdir` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeOnDelete":
            suggest = "remove_on_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MkdirOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MkdirOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MkdirOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 directory: str,
                 parents: Optional[bool] = None,
                 remove_on_delete: Optional[bool] = None):
        """
        Abstraction over the `mkdir` utility on a remote system.
        :param str directory: The fully qualified path of the directory on the remote system.
        :param bool parents: Corresponds to the `--parents` option.
        :param bool remove_on_delete: Remove the created directory when the `Mkdir` resource is deleted or updated.
        """
        pulumi.set(__self__, "directory", directory)
        if parents is not None:
            pulumi.set(__self__, "parents", parents)
        if remove_on_delete is not None:
            pulumi.set(__self__, "remove_on_delete", remove_on_delete)

    @property
    @pulumi.getter
    def directory(self) -> str:
        """
        The fully qualified path of the directory on the remote system.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def parents(self) -> Optional[bool]:
        """
        Corresponds to the `--parents` option.
        """
        return pulumi.get(self, "parents")

    @property
    @pulumi.getter(name="removeOnDelete")
    def remove_on_delete(self) -> Optional[bool]:
        """
        Remove the created directory when the `Mkdir` resource is deleted or updated.
        """
        return pulumi.get(self, "remove_on_delete")


@pulumi.output_type
class MktempOpts(dict):
    """
    Abstraction over the `mktemp` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dryRun":
            suggest = "dry_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MktempOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MktempOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MktempOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 directory: Optional[bool] = None,
                 dry_run: Optional[bool] = None,
                 quiet: Optional[bool] = None,
                 suffix: Optional[str] = None,
                 template: Optional[str] = None,
                 tmpdir: Optional[str] = None):
        """
        Abstraction over the `mktemp` utility on a remote system.
        :param bool directory: Corresponds to the `--directory` option.
        :param bool dry_run: Corresponds to the `--dry-run` option.
        :param bool quiet: Corresponds to the `--quiet` option.
        :param str suffix: Corresponds to the `--suffix` option.
        :param str template: Corresponds to the [TEMPLATE] argument.
        :param str tmpdir: Corresponds to the `--tmpdir` option.
        """
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if dry_run is not None:
            pulumi.set(__self__, "dry_run", dry_run)
        if quiet is not None:
            pulumi.set(__self__, "quiet", quiet)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tmpdir is not None:
            pulumi.set(__self__, "tmpdir", tmpdir)

    @property
    @pulumi.getter
    def directory(self) -> Optional[bool]:
        """
        Corresponds to the `--directory` option.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> Optional[bool]:
        """
        Corresponds to the `--dry-run` option.
        """
        return pulumi.get(self, "dry_run")

    @property
    @pulumi.getter
    def quiet(self) -> Optional[bool]:
        """
        Corresponds to the `--quiet` option.
        """
        return pulumi.get(self, "quiet")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Corresponds to the `--suffix` option.
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        Corresponds to the [TEMPLATE] argument.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def tmpdir(self) -> Optional[str]:
        """
        Corresponds to the `--tmpdir` option.
        """
        return pulumi.get(self, "tmpdir")


@pulumi.output_type
class MvOpts(dict):
    """
    Abstraction over the `mv` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noClobber":
            suggest = "no_clobber"
        elif key == "noTargetDirectory":
            suggest = "no_target_directory"
        elif key == "stripTrailingSlashes":
            suggest = "strip_trailing_slashes"
        elif key == "targetDirectory":
            suggest = "target_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MvOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MvOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MvOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: Sequence[str],
                 backup: Optional[bool] = None,
                 context: Optional[bool] = None,
                 control: Optional[bool] = None,
                 dest: Optional[str] = None,
                 directory: Optional[str] = None,
                 force: Optional[bool] = None,
                 no_clobber: Optional[bool] = None,
                 no_target_directory: Optional[bool] = None,
                 strip_trailing_slashes: Optional[bool] = None,
                 suffix: Optional[str] = None,
                 target_directory: Optional[bool] = None,
                 update: Optional[bool] = None,
                 verbose: Optional[bool] = None):
        """
        Abstraction over the `mv` utility on a remote system.
        :param Sequence[str] source: Corresponds to the [SOURCE] argument.
        :param bool backup: Corresponds to the `-b` and `--backup` options depending on whether [CONTROL] is supplied.
        :param bool context: Corresponds to the `--context` option.
        :param bool control: Corresponds to the [CONTROL] argument for the `--backup` option.
        :param str dest: Corresponds to the [DEST] argument.
        :param str directory: Corresponds to the [DIRECTORY] argument.
        :param bool force: Corresponds to the `--force` option.
        :param bool no_clobber: Corresponds to the `--no-clobber` option.
        :param bool no_target_directory: Corresponds to the `--no-target-directory` option.
        :param bool strip_trailing_slashes: Corresponds to the `--strip-trailing-slashes` option.
        :param str suffix: Corresponds to the `--suffix` option.
        :param bool target_directory: Corresponds to the `--target-directory` option.
        :param bool update: Corresponds to the `--update` option.
        :param bool verbose: Corresponds to the `--verbose` option.
        """
        pulumi.set(__self__, "source", source)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if control is not None:
            pulumi.set(__self__, "control", control)
        if dest is not None:
            pulumi.set(__self__, "dest", dest)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if no_clobber is not None:
            pulumi.set(__self__, "no_clobber", no_clobber)
        if no_target_directory is not None:
            pulumi.set(__self__, "no_target_directory", no_target_directory)
        if strip_trailing_slashes is not None:
            pulumi.set(__self__, "strip_trailing_slashes", strip_trailing_slashes)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if target_directory is not None:
            pulumi.set(__self__, "target_directory", target_directory)
        if update is not None:
            pulumi.set(__self__, "update", update)
        if verbose is not None:
            pulumi.set(__self__, "verbose", verbose)

    @property
    @pulumi.getter
    def source(self) -> Sequence[str]:
        """
        Corresponds to the [SOURCE] argument.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def backup(self) -> Optional[bool]:
        """
        Corresponds to the `-b` and `--backup` options depending on whether [CONTROL] is supplied.
        """
        return pulumi.get(self, "backup")

    @property
    @pulumi.getter
    def context(self) -> Optional[bool]:
        """
        Corresponds to the `--context` option.
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def control(self) -> Optional[bool]:
        """
        Corresponds to the [CONTROL] argument for the `--backup` option.
        """
        return pulumi.get(self, "control")

    @property
    @pulumi.getter
    def dest(self) -> Optional[str]:
        """
        Corresponds to the [DEST] argument.
        """
        return pulumi.get(self, "dest")

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        Corresponds to the [DIRECTORY] argument.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        """
        Corresponds to the `--force` option.
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter(name="noClobber")
    def no_clobber(self) -> Optional[bool]:
        """
        Corresponds to the `--no-clobber` option.
        """
        return pulumi.get(self, "no_clobber")

    @property
    @pulumi.getter(name="noTargetDirectory")
    def no_target_directory(self) -> Optional[bool]:
        """
        Corresponds to the `--no-target-directory` option.
        """
        return pulumi.get(self, "no_target_directory")

    @property
    @pulumi.getter(name="stripTrailingSlashes")
    def strip_trailing_slashes(self) -> Optional[bool]:
        """
        Corresponds to the `--strip-trailing-slashes` option.
        """
        return pulumi.get(self, "strip_trailing_slashes")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        """
        Corresponds to the `--suffix` option.
        """
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter(name="targetDirectory")
    def target_directory(self) -> Optional[bool]:
        """
        Corresponds to the `--target-directory` option.
        """
        return pulumi.get(self, "target_directory")

    @property
    @pulumi.getter
    def update(self) -> Optional[bool]:
        """
        Corresponds to the `--update` option.
        """
        return pulumi.get(self, "update")

    @property
    @pulumi.getter
    def verbose(self) -> Optional[bool]:
        """
        Corresponds to the `--verbose` option.
        """
        return pulumi.get(self, "verbose")


@pulumi.output_type
class RmOpts(dict):
    """
    Abstraction over the `rm` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDelete":
            suggest = "on_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RmOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RmOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RmOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 files: Sequence[str],
                 dir: Optional[bool] = None,
                 force: Optional[bool] = None,
                 on_delete: Optional[bool] = None,
                 recursive: Optional[bool] = None,
                 verbose: Optional[bool] = None):
        """
        Abstraction over the `rm` utility on a remote system.
        :param Sequence[str] files: Corresponds to the [FILE] argument.
        :param bool dir: Corresponds to the `--dir` option.
        :param bool force: Corresponds to the `--force` option.
        :param bool on_delete: Whether rm should be run when the resource is created or deleted.
        :param bool recursive: Corresponds to the `--recursive` option.
        :param bool verbose: Corresponds to the `--verbose` option.
        """
        pulumi.set(__self__, "files", files)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if on_delete is not None:
            pulumi.set(__self__, "on_delete", on_delete)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if verbose is not None:
            pulumi.set(__self__, "verbose", verbose)

    @property
    @pulumi.getter
    def files(self) -> Sequence[str]:
        """
        Corresponds to the [FILE] argument.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def dir(self) -> Optional[bool]:
        """
        Corresponds to the `--dir` option.
        """
        return pulumi.get(self, "dir")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        """
        Corresponds to the `--force` option.
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter(name="onDelete")
    def on_delete(self) -> Optional[bool]:
        """
        Whether rm should be run when the resource is created or deleted.
        """
        return pulumi.get(self, "on_delete")

    @property
    @pulumi.getter
    def recursive(self) -> Optional[bool]:
        """
        Corresponds to the `--recursive` option.
        """
        return pulumi.get(self, "recursive")

    @property
    @pulumi.getter
    def verbose(self) -> Optional[bool]:
        """
        Corresponds to the `--verbose` option.
        """
        return pulumi.get(self, "verbose")


@pulumi.output_type
class SedOpts(dict):
    """
    Abstraction over the `sed` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "followSymlinks":
            suggest = "follow_symlinks"
        elif key == "inPlace":
            suggest = "in_place"
        elif key == "inputFiles":
            suggest = "input_files"
        elif key == "lineLength":
            suggest = "line_length"
        elif key == "nullData":
            suggest = "null_data"
        elif key == "regexpExtended":
            suggest = "regexp_extended"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SedOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SedOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SedOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 debug: Optional[bool] = None,
                 expressions: Optional[Sequence[str]] = None,
                 files: Optional[Sequence[str]] = None,
                 follow_symlinks: Optional[bool] = None,
                 help: Optional[bool] = None,
                 in_place: Optional[str] = None,
                 input_files: Optional[Sequence[str]] = None,
                 line_length: Optional[int] = None,
                 null_data: Optional[bool] = None,
                 posix: Optional[bool] = None,
                 quiet: Optional[bool] = None,
                 regexp_extended: Optional[bool] = None,
                 sandbox: Optional[bool] = None,
                 script: Optional[str] = None,
                 separate: Optional[bool] = None,
                 silent: Optional[bool] = None,
                 unbuffered: Optional[bool] = None,
                 version: Optional[bool] = None):
        """
        Abstraction over the `sed` utility on a remote system.
        :param bool debug: annotate program execution.
        :param Sequence[str] expressions: add the script to the commands to be executed.
        :param Sequence[str] files: add the contents of script-file to the commands to be executed.
        :param bool follow_symlinks: follow symlinks when processing in place
        :param bool help: display this help and exit.
        :param str in_place: edit files in place (makes backup if SUFFIX supplied)
        :param Sequence[str] input_files: corresponds to the [input-file]... argument(s).
        :param int line_length: specify the desired line-wrap length for the `l' command
        :param bool null_data: separate lines by NUL characters
        :param bool posix: disable all GNU extensions.
        :param bool quiet: suppress automatic printing of pattern space. Same as `silent`.
        :param bool regexp_extended: use extended regular expressions in the script (for portability use POSIX -E).
        :param bool sandbox: operate in sandbox mode (disable e/r/w commands).
        :param str script: script only if no other script.
        :param bool separate: consider files as separate rather than as a single, continuous long stream.
        :param bool silent: suppress automatic printing of pattern space. Same as `quiet`.
        :param bool unbuffered: load minimal amounts of data from the input files and flush the output buffers more often.
        :param bool version: output version information and exit.
        """
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if expressions is not None:
            pulumi.set(__self__, "expressions", expressions)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if follow_symlinks is not None:
            pulumi.set(__self__, "follow_symlinks", follow_symlinks)
        if help is not None:
            pulumi.set(__self__, "help", help)
        if in_place is not None:
            pulumi.set(__self__, "in_place", in_place)
        if input_files is not None:
            pulumi.set(__self__, "input_files", input_files)
        if line_length is not None:
            pulumi.set(__self__, "line_length", line_length)
        if null_data is not None:
            pulumi.set(__self__, "null_data", null_data)
        if posix is not None:
            pulumi.set(__self__, "posix", posix)
        if quiet is not None:
            pulumi.set(__self__, "quiet", quiet)
        if regexp_extended is not None:
            pulumi.set(__self__, "regexp_extended", regexp_extended)
        if sandbox is not None:
            pulumi.set(__self__, "sandbox", sandbox)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if separate is not None:
            pulumi.set(__self__, "separate", separate)
        if silent is not None:
            pulumi.set(__self__, "silent", silent)
        if unbuffered is not None:
            pulumi.set(__self__, "unbuffered", unbuffered)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        """
        annotate program execution.
        """
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter
    def expressions(self) -> Optional[Sequence[str]]:
        """
        add the script to the commands to be executed.
        """
        return pulumi.get(self, "expressions")

    @property
    @pulumi.getter
    def files(self) -> Optional[Sequence[str]]:
        """
        add the contents of script-file to the commands to be executed.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter(name="followSymlinks")
    def follow_symlinks(self) -> Optional[bool]:
        """
        follow symlinks when processing in place
        """
        return pulumi.get(self, "follow_symlinks")

    @property
    @pulumi.getter
    def help(self) -> Optional[bool]:
        """
        display this help and exit.
        """
        return pulumi.get(self, "help")

    @property
    @pulumi.getter(name="inPlace")
    def in_place(self) -> Optional[str]:
        """
        edit files in place (makes backup if SUFFIX supplied)
        """
        return pulumi.get(self, "in_place")

    @property
    @pulumi.getter(name="inputFiles")
    def input_files(self) -> Optional[Sequence[str]]:
        """
        corresponds to the [input-file]... argument(s).
        """
        return pulumi.get(self, "input_files")

    @property
    @pulumi.getter(name="lineLength")
    def line_length(self) -> Optional[int]:
        """
        specify the desired line-wrap length for the `l' command
        """
        return pulumi.get(self, "line_length")

    @property
    @pulumi.getter(name="nullData")
    def null_data(self) -> Optional[bool]:
        """
        separate lines by NUL characters
        """
        return pulumi.get(self, "null_data")

    @property
    @pulumi.getter
    def posix(self) -> Optional[bool]:
        """
        disable all GNU extensions.
        """
        return pulumi.get(self, "posix")

    @property
    @pulumi.getter
    def quiet(self) -> Optional[bool]:
        """
        suppress automatic printing of pattern space. Same as `silent`.
        """
        return pulumi.get(self, "quiet")

    @property
    @pulumi.getter(name="regexpExtended")
    def regexp_extended(self) -> Optional[bool]:
        """
        use extended regular expressions in the script (for portability use POSIX -E).
        """
        return pulumi.get(self, "regexp_extended")

    @property
    @pulumi.getter
    def sandbox(self) -> Optional[bool]:
        """
        operate in sandbox mode (disable e/r/w commands).
        """
        return pulumi.get(self, "sandbox")

    @property
    @pulumi.getter
    def script(self) -> Optional[str]:
        """
        script only if no other script.
        """
        return pulumi.get(self, "script")

    @property
    @pulumi.getter
    def separate(self) -> Optional[bool]:
        """
        consider files as separate rather than as a single, continuous long stream.
        """
        return pulumi.get(self, "separate")

    @property
    @pulumi.getter
    def silent(self) -> Optional[bool]:
        """
        suppress automatic printing of pattern space. Same as `quiet`.
        """
        return pulumi.get(self, "silent")

    @property
    @pulumi.getter
    def unbuffered(self) -> Optional[bool]:
        """
        load minimal amounts of data from the input files and flush the output buffers more often.
        """
        return pulumi.get(self, "unbuffered")

    @property
    @pulumi.getter
    def version(self) -> Optional[bool]:
        """
        output version information and exit.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SystemctlOpts(dict):
    """
    Abstraction over the `systemctl` utility on a remote system.
    """
    def __init__(__self__, *,
                 command: 'SystemctlCommand',
                 unit: str,
                 now: Optional[bool] = None,
                 pattern: Optional[str] = None):
        """
        Abstraction over the `systemctl` utility on a remote system.
        :param 'SystemctlCommand' command: Corresponds to the COMMAND argument.
        :param str unit: Corresponds to the [UNIT...] argument.
        :param bool now: Corresponds to the `--now` option.
        :param str pattern: Corresponds to the [PATTERN] argument
        """
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "unit", unit)
        if now is not None:
            pulumi.set(__self__, "now", now)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def command(self) -> 'SystemctlCommand':
        """
        Corresponds to the COMMAND argument.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Corresponds to the [UNIT...] argument.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def now(self) -> Optional[bool]:
        """
        Corresponds to the `--now` option.
        """
        return pulumi.get(self, "now")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Corresponds to the [PATTERN] argument
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class TarOpts(dict):
    """
    Abstraction over the `tar` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDelete":
            suggest = "on_delete"
        elif key == "stripComponents":
            suggest = "strip_components"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TarOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TarOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TarOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive: str,
                 directory: Optional[str] = None,
                 extract: Optional[bool] = None,
                 files: Optional[Sequence[str]] = None,
                 gzip: Optional[bool] = None,
                 on_delete: Optional[bool] = None,
                 recursive: Optional[bool] = None,
                 strip_components: Optional[int] = None):
        """
        Abstraction over the `tar` utility on a remote system.
        :param str archive: Corresponds to the [ARCHIVE] argument.
        :param str directory: Corresponds to the `--directory` option.
        :param bool extract: Corresponds to the `--extract` option.
        :param Sequence[str] files: Corresponds to the [FILE] argument.
        :param bool gzip: Corresponds to the `--gzip` option.
        :param bool on_delete: Whether rm should be run when the resource is created or deleted.
        :param bool recursive: Corresponds to the `--recursive` option.
        :param int strip_components: Corresponds to the `--strip-components` option.
        """
        pulumi.set(__self__, "archive", archive)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if extract is not None:
            pulumi.set(__self__, "extract", extract)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if on_delete is not None:
            pulumi.set(__self__, "on_delete", on_delete)
        if recursive is not None:
            pulumi.set(__self__, "recursive", recursive)
        if strip_components is not None:
            pulumi.set(__self__, "strip_components", strip_components)

    @property
    @pulumi.getter
    def archive(self) -> str:
        """
        Corresponds to the [ARCHIVE] argument.
        """
        return pulumi.get(self, "archive")

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        Corresponds to the `--directory` option.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def extract(self) -> Optional[bool]:
        """
        Corresponds to the `--extract` option.
        """
        return pulumi.get(self, "extract")

    @property
    @pulumi.getter
    def files(self) -> Optional[Sequence[str]]:
        """
        Corresponds to the [FILE] argument.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def gzip(self) -> Optional[bool]:
        """
        Corresponds to the `--gzip` option.
        """
        return pulumi.get(self, "gzip")

    @property
    @pulumi.getter(name="onDelete")
    def on_delete(self) -> Optional[bool]:
        """
        Whether rm should be run when the resource is created or deleted.
        """
        return pulumi.get(self, "on_delete")

    @property
    @pulumi.getter
    def recursive(self) -> Optional[bool]:
        """
        Corresponds to the `--recursive` option.
        """
        return pulumi.get(self, "recursive")

    @property
    @pulumi.getter(name="stripComponents")
    def strip_components(self) -> Optional[int]:
        """
        Corresponds to the `--strip-components` option.
        """
        return pulumi.get(self, "strip_components")


@pulumi.output_type
class TeeOpts(dict):
    """
    Abstraction over the `rm` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreInterrupts":
            suggest = "ignore_interrupts"
        elif key == "outputError":
            suggest = "output_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeeOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeeOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeeOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 files: Sequence[str],
                 append: Optional[bool] = None,
                 ignore_interrupts: Optional[bool] = None,
                 output_error: Optional['TeeMode'] = None,
                 pipe: Optional[bool] = None,
                 version: Optional[bool] = None):
        """
        Abstraction over the `rm` utility on a remote system.
        :param Sequence[str] files: Corresponds to the [FILE] argument.
        :param bool append: Append to the given FILEs, do not overwrite
        :param bool ignore_interrupts: Ignore interrupt signals.
        :param 'TeeMode' output_error: Set behavior on write error.
        :param bool pipe: Operate in a more appropriate MODE with pipes.
        :param bool version: Output version information and exit.
        """
        pulumi.set(__self__, "files", files)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if ignore_interrupts is not None:
            pulumi.set(__self__, "ignore_interrupts", ignore_interrupts)
        if output_error is not None:
            pulumi.set(__self__, "output_error", output_error)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def files(self) -> Sequence[str]:
        """
        Corresponds to the [FILE] argument.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def append(self) -> Optional[bool]:
        """
        Append to the given FILEs, do not overwrite
        """
        return pulumi.get(self, "append")

    @property
    @pulumi.getter(name="ignoreInterrupts")
    def ignore_interrupts(self) -> Optional[bool]:
        """
        Ignore interrupt signals.
        """
        return pulumi.get(self, "ignore_interrupts")

    @property
    @pulumi.getter(name="outputError")
    def output_error(self) -> Optional['TeeMode']:
        """
        Set behavior on write error.
        """
        return pulumi.get(self, "output_error")

    @property
    @pulumi.getter
    def pipe(self) -> Optional[bool]:
        """
        Operate in a more appropriate MODE with pipes.
        """
        return pulumi.get(self, "pipe")

    @property
    @pulumi.getter
    def version(self) -> Optional[bool]:
        """
        Output version information and exit.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WgetOpts(dict):
    """
    Abstraction over the `wget` utility on a remote system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "directoryPrefix":
            suggest = "directory_prefix"
        elif key == "httpsOnly":
            suggest = "https_only"
        elif key == "noVerbose":
            suggest = "no_verbose"
        elif key == "outputDocument":
            suggest = "output_document"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WgetOpts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WgetOpts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WgetOpts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: Sequence[str],
                 directory_prefix: Optional[str] = None,
                 https_only: Optional[bool] = None,
                 no_verbose: Optional[bool] = None,
                 output_document: Optional[str] = None,
                 quiet: Optional[bool] = None,
                 timestamping: Optional[bool] = None):
        """
        Abstraction over the `wget` utility on a remote system.
        :param Sequence[str] url: Corresponds to the [URL...] argument.
        :param str directory_prefix: The  directory prefix is the directory where all other files and subdirectories will be saved to, i.e. the top of the retrieval tree.  The default is . (the current directory).
        :param bool https_only: When in recursive mode, only HTTPS links are followed.
        :param bool no_verbose: Turn off verbose without being completely quiet (use -q for that), which means that error messages and basic information still get printed.
        :param str output_document: The  documents  will  not  be  written  to the appropriate files, but all will be concatenated together and written to file.
        :param bool quiet: Turn off Wget's output.
        :param bool timestamping: Turn on time-stamping.
        """
        pulumi.set(__self__, "url", url)
        if directory_prefix is not None:
            pulumi.set(__self__, "directory_prefix", directory_prefix)
        if https_only is not None:
            pulumi.set(__self__, "https_only", https_only)
        if no_verbose is not None:
            pulumi.set(__self__, "no_verbose", no_verbose)
        if output_document is not None:
            pulumi.set(__self__, "output_document", output_document)
        if quiet is not None:
            pulumi.set(__self__, "quiet", quiet)
        if timestamping is not None:
            pulumi.set(__self__, "timestamping", timestamping)

    @property
    @pulumi.getter
    def url(self) -> Sequence[str]:
        """
        Corresponds to the [URL...] argument.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="directoryPrefix")
    def directory_prefix(self) -> Optional[str]:
        """
        The  directory prefix is the directory where all other files and subdirectories will be saved to, i.e. the top of the retrieval tree.  The default is . (the current directory).
        """
        return pulumi.get(self, "directory_prefix")

    @property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> Optional[bool]:
        """
        When in recursive mode, only HTTPS links are followed.
        """
        return pulumi.get(self, "https_only")

    @property
    @pulumi.getter(name="noVerbose")
    def no_verbose(self) -> Optional[bool]:
        """
        Turn off verbose without being completely quiet (use -q for that), which means that error messages and basic information still get printed.
        """
        return pulumi.get(self, "no_verbose")

    @property
    @pulumi.getter(name="outputDocument")
    def output_document(self) -> Optional[str]:
        """
        The  documents  will  not  be  written  to the appropriate files, but all will be concatenated together and written to file.
        """
        return pulumi.get(self, "output_document")

    @property
    @pulumi.getter
    def quiet(self) -> Optional[bool]:
        """
        Turn off Wget's output.
        """
        return pulumi.get(self, "quiet")

    @property
    @pulumi.getter
    def timestamping(self) -> Optional[bool]:
        """
        Turn on time-stamping.
        """
        return pulumi.get(self, "timestamping")


